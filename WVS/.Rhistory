A009 = 5-ifelse(A009 < 0, yes=NA, no=A009),
A170 =   ifelse(A170 < 0, yes=NA, no=A170),
A173 =   ifelse(A173 < 0, yes=NA, no=A173),
C006 =   ifelse(C006 < 0, yes=NA, no=C006),
X001 =   ifelse(X001 < 0, yes=NA, no=X001),
X003 =   ifelse(X003 < 0, yes=NA, no=X003/10))
## Load the data
load("WVS.Rdata")
table(WVS[, c("S002","S003")])
## Select the relevant variables to minimize memory usage
WVS <- select(WVS, c(A009, A170, A173, C006, X001, X003, S002, S003))
## Reverse coding for A009
## Recode all negative values as NA
## Age (X003) is divided by 10 to improve numerical stability.
WVS <- mutate(WVS,
A009 = 5-ifelse(A009 < 0, yes=NA, no=A009),
A170 =   ifelse(A170 < 0, yes=NA, no=A170),
A173 =   ifelse(A173 < 0, yes=NA, no=A173),
C006 =   ifelse(C006 < 0, yes=NA, no=C006),
X001 =   ifelse(X001 < 0, yes=NA, no=X001),
X003 =   ifelse(X003 < 0, yes=NA, no=X003/10))
```
* We conduct the same regression analysis in each `Wave` and `Country`.
* `Wave` is used as a moderator in predicting the estimated regression coefficients (effect sizes).
```{r, cache=FALSE}
## Function to fit regression model
## y1 to y5: Regression coefficients from A170, A009, A173, C006, X001, and X003.
## v11 to v55: Sampling covariance matrix of the parameter estimates
fun.reg <- function(dt) { fit <- try(lm(A170~A009+A173+C006+X001+X003, data=dt),
silent=TRUE)
## If there are errors during the analysis, it returns missing values.
if (is.element("try-error", class(fit))) {
c(y1=NA,y2=NA,y3=NA,y4=NA,y5=NA,
v11=NA,v21=NA,v31=NA,v41=NA,v51=NA,
v22=NA,v32=NA,v42=NA,v52=NA,v33=NA,
v43=NA,v53=NA,v44=NA,v54=NA,v55=NA)
} else {
## Extract the regression coefficients excluding the intercept
y <- unname(coef(fit))
## Extract the sampling covariance matrix excluding the intercept
v <- lav_matrix_vech(vcov(fit)[-1,-1])
c(y1=y[2],y2=y[3],y3=y[4],y4=y[5],y5=y[6],
v11=v[1],v21=v[2],v31=v[3],v41=v[4],v51=v[5],
v22=v[6],v32=v[7],v42=v[8],v52=v[9],v33=v[10],
v43=v[11],v53=v[12],v44=v[13],v54=v[14],v55=v[15])
}
}
nrow(WVS)
FEM1.reg <- WVS %>% group_by(Study) %>% do(mod=(fun.reg(.)))
FEM1.reg
## Convert it into a data frame
FEM1.reg <- as.data.frame(t(sapply(FEM1.reg$mod, function(x) x)))
## Show part of the results
head(FEM1.reg)
########## Meta-analyze results with a multivariate fixed-effects meta-analysis:
########## Variance component is fixed at 0: RE.constraints=matrix(0, ncol=5, nrow=5)
FEM2.reg <- meta(y=cbind(y1,y2,y3,y4,y5),
v=cbind(v11,v21,v31,v41,v51,v22,v32,v42,v52,v33,v43,v53,v44,v54,v55),
data=FEM1.reg, RE.constraints=matrix(0, ncol=5, nrow=5),
model.name="Regression analysis FEM")
summary(FEM2.reg)
library(metaSEM)
FEM1.reg <- WVS %>% group_by(Study) %>% do(mod=(fun.reg(.)))
FEM1.reg
## Convert it into a data frame
FEM1.reg <- as.data.frame(t(sapply(FEM1.reg$mod, function(x) x)))
## Show part of the results
head(FEM1.reg)
########## Meta-analyze results with a multivariate fixed-effects meta-analysis:
########## Variance component is fixed at 0: RE.constraints=matrix(0, ncol=5, nrow=5)
FEM2.reg <- meta(y=cbind(y1,y2,y3,y4,y5),
v=cbind(v11,v21,v31,v41,v51,v22,v32,v42,v52,v33,v43,v53,v44,v54,v55),
data=FEM1.reg, RE.constraints=matrix(0, ncol=5, nrow=5),
model.name="Regression analysis FEM")
summary(FEM2.reg)
library(dplyr)
library(lavaan)
## Load the data
load("WVS.Rdata")
## Select the relevant variables to minimize the memory usage
WVS <- select(WVS, c(A009, A170, A173, C006, X001, X003, S002, S003))
## Data cleaning
## Reverse coding for A009
## Recode all negative values as NA
## Age (X003) is divided by 10 to improve numerical stability.
WVS <- mutate(WVS,
A009 = 5-ifelse(A009 < 0, yes=NA, no=A009),
A170 =   ifelse(A170 < 0, yes=NA, no=A170),
A173 =   ifelse(A173 < 0, yes=NA, no=A173),
C006 =   ifelse(C006 < 0, yes=NA, no=C006),
X001 =   ifelse(X001 < 0, yes=NA, no=X001),
X003 =   ifelse(X003 < 0, yes=NA, no=X003/10))
## No. of studies
k <- 100
## Set seed for reproducibility
set.seed (871139100)
## Randomly split the data into 100 studies
Study <- sample(1:nrow(WVS)) %% k + 1
## Show the sample sizes in the studies
table(Study)
## Append "Study" into the dataset
WVS$Study <- Study
## Function to fit regression analysis
## y1 to y5: Regression coefficients for A009, A173, C006, X001, and X003.
## v11 to v55: Sampling covariance matrix of the parameter estimates
fun.reg <- function(dt) { fit <- try(lm(A170~A009+A173+C006+X001+X003, data=dt),
silent=TRUE)
## If there are errors during the analysis, it returns missing values.
if (is.element("try-error", class(fit))) {
c(y1=NA,y2=NA,y3=NA,y4=NA,y5=NA,
v11=NA,v21=NA,v31=NA,v41=NA,v51=NA,
v22=NA,v32=NA,v42=NA,v52=NA,v33=NA,
v43=NA,v53=NA,v44=NA,v54=NA,v55=NA)
} else {
## Extract the regression coefficients excluding the intercept
y <- unname(coef(fit))
## Extract the sampling covariance matrix excluding the intercept
v <- lav_matrix_vech(vcov(fit)[-1,-1])
c(y1=y[2],y2=y[3],y3=y[4],y4=y[5],y5=y[6],
v11=v[1],v21=v[2],v31=v[3],v41=v[4],v51=v[5],
v22=v[6],v32=v[7],v42=v[8],v52=v[9],v33=v[10],
v43=v[11],v53=v[12],v44=v[13],v54=v[14],v55=v[15])
}
}
########## Split data by "Study" and analyze data with the fun.reg() function on each "Study"
FEM1.reg <- WVS %>% group_by(Study) %>% do(mod=(fun.reg(.)))
FEM1.reg
## Convert it into a data frame
FEM1.reg <- as.data.frame(t(sapply(FEM1.reg$mod, function(x) x)))
## Show part of the results
head(FEM1.reg)
########## Meta-analyze results with a multivariate fixed-effects meta-analysis:
########## Variance component is fixed at 0: RE.constraints=matrix(0, ncol=5, nrow=5)
FEM2.reg <- meta(y=cbind(y1,y2,y3,y4,y5),
v=cbind(v11,v21,v31,v41,v51,v22,v32,v42,v52,v33,v43,v53,v44,v54,v55),
data=FEM1.reg, RE.constraints=matrix(0, ncol=5, nrow=5),
model.name="Regression analysis FEM")
summary(FEM2.reg)
plot(FEM2.reg)
plot(FEM2.reg)
########## Meta-analyze results with a mixed-effects meta-analysis by using "Wave"" as a predictor
RE.constraints <- Diag(paste(0.1, "*Tau2_", 1:5, "_", 1:5, sep = ""))
########## Meta-analyze results with a mixed-effects meta-analysis by using "Wave"" as a predictor
RE.constraints <- Diag(paste(0.1, "*Tau2_", 1:5, "_", 1:5, sep = ""))
RE.constraints
rm(list=ls())
## Load the data
load("WVS.Rdata")
## Sample sizes of S002 (Wave) and S003 (Country)
## Please refer to http://www.worldvaluessurvey.org/WVSDocumentationWVL.jsp
## for the country names.
table(WVS[, c("S002","S003")])
## Select the relevant variables to minimize memory usage
WVS <- select(WVS, c(A009, A170, A173, C006, X001, X003, S002, S003))
## Reverse coding for A009
## Recode all negative values as NA
## Age (X003) is divided by 10 to improve numerical stability.
WVS <- mutate(WVS,
A009 = 5-ifelse(A009 < 0, yes=NA, no=A009),
A170 =   ifelse(A170 < 0, yes=NA, no=A170),
A173 =   ifelse(A173 < 0, yes=NA, no=A173),
C006 =   ifelse(C006 < 0, yes=NA, no=C006),
X001 =   ifelse(X001 < 0, yes=NA, no=X001),
X003 =   ifelse(X003 < 0, yes=NA, no=X003/10))
fun.reg <- function(dt) { fit <- try(lm(A170~A009+A173+C006+X001+X003, data=dt), silent=TRUE)
## If there are errors during the analysis, it returns missing values.
if (is.element("try-error", class(fit))) {
c(y1=NA,y2=NA,y3=NA,y4=NA,y5=NA,
v11=NA,v21=NA,v31=NA,v41=NA,v51=NA,
v22=NA,v32=NA,v42=NA,v52=NA,v33=NA,
v43=NA,v53=NA,v44=NA,v54=NA,v55=NA)
} else {
## Extract the regression coefficients excluding the intercept
y <- unname(coef(fit))
## Extract the sampling covariance matrix excluding the intercept
v <- lav_matrix_vech(vcov(fit)[-1,-1])
c(y1=y[2],y2=y[3],y3=y[4],y4=y[5],y5=y[6],
v11=v[1],v21=v[2],v31=v[3],v41=v[4],v51=v[5],
v22=v[6],v32=v[7],v42=v[8],v52=v[9],v33=v[10],
v43=v[11],v53=v[12],v44=v[13],v54=v[14],v55=v[15])
}
}
########## Split data by Wave and Country and analyze with the fun.reg() function
## Set Wave and Country as key variables for fast reference
## S002: Wave (1 to 6)
## S003: Country
REM1.reg <- WVS %>% group_by(S002, S003) %>% do(mod=(fun.reg(.)))
## Convert it into a data frame and append S002 in the dataset
REM1.reg <- data.frame(S002=REM1.reg$S002,
as.data.frame(t(sapply(REM1.reg$mod, function(x) x))))
REM2.reg <- meta(y=cbind(y1,y2,y3,y4,y5),
v=cbind(v11,v21,v31,v41,v51,v22,v32,v42,v52,v33,v43,v53,v44,v54,v55),
data=REM1.reg,
model.name="Regression analysis REM")
## Rerun the analysis to remove error code
# REM2.reg <- rerun(REM2.reg)
summary(REM2.reg)
nrow(REM1.reg)
head(REM1.reg)
REM1.reg$S002
REM3.reg <- meta(y=cbind(y1,y2,y3,y4,y5),
v=cbind(v11,v21,v31,v41,v51,v22,v32,v42,v52,v33,v43,v53,v44,v54,v55),
x=S002, data=REM1.reg,
model.name="Wave as a moderator")
## Rerun the analysis to remove error code
# REM2.reg <- rerun(REM2.reg)
summary(REM3.reg)
REM1.reg$S002 <- REM1.reg$S002-1
REM3.reg <- meta(y=cbind(y1,y2,y3,y4,y5),
v=cbind(v11,v21,v31,v41,v51,v22,v32,v42,v52,v33,v43,v53,v44,v54,v55),
x=S002, data=REM1.reg,
model.name="Wave as a moderator")
## Rerun the analysis to remove error code
# REM2.reg <- rerun(REM2.reg)
summary(REM3.reg)
library(dplyr)
library(lavaan)
library(metaSEM)
## Try to use multiple cores in OpenMx. It may speed up some of the analyses.
mxOption(NULL, 'Number of Threads', (parallel::detectCores()-1))
load("WVS_complete.Rdata")
library(dplyr)
library(lavaan)
library(metaSEM)
## Try to use multiple cores in OpenMx. It may speed up some of the analyses.
mxOption(NULL, 'Number of Threads', (parallel::detectCores()-1))
## Load the data
load("WVS_complete.Rdata")
fun.rel <- function(dt) { my.dt <- dt[, c("F114", "F115", "F116", "F117")]
Cov <- try(cov(my.dt,
use="pairwise.complete.obs"), silent=TRUE)
na.n <- t(!is.na(my.dt)) %*% !is.na(my.dt)
pairwise.n <- na.n[lower.tri(na.n, diag=TRUE)]
pairwise.n[pairwise.n==0] <- NA
## harmonic mean
n <- as.integer(1/mean(1/pairwise.n, na.rm=TRUE))
if (is.element("try-error", class(Cov))) {
c(y=NA,v=NA)
} else {
if (any(is.na(Cov))) {
c(y=NA,v=NA)
} else {
## no. of items
q <- ncol(Cov)
var.item <- sum(diag(Cov))
var.scale <- sum(Cov)
## y: coefficient alpha
y <- q*(1-var.item/var.scale)/(q-1)
## Bonett (2010, Eq.5)
## v: sampling variance of y (Bonett, 2010, Eq. 5)
v <- 2*q*(1-y)^2/((q-1)*(n-2))
c(y=y,v=v)
}
}
}
########## Split data by Wave and Country and analyze data with the fun.rel() function
REM1.rel <- WVS %>% group_by(S002, S003) %>% do(mod=(fun.rel(.)))
head(REM1.rel)
REM1.rel <- data.frame(S002=REM1.rel$S002-1,
as.data.frame(t(sapply(REM1.rel$mod, function(x) x))))
head(REM1.rel)
REM2.rel <- meta(y=y, v=v, data=REM1.rel,
model.name="Reliability generalization REM")
summary(REM2.rel)
library(dplyr)
library(lavaan)
library(metaSEM)
## Try to use multiple cores in OpenMx. It may speed up some of the analyses.
mxOption(NULL, 'Number of Threads', (parallel::detectCores()-1))
## Load the data
load("WVS.Rdata")
## Select the relevant variables to minimize the memory usage
WVS <- select(WVS, c(A009, A170, A173, C006, X001, X003, S002, S003))
table(WVS$S002)
table(WVS$S003)
library(metaSEM)
library(semPlot)
library(lavaan)
my.model <- "A170~y1*A009+y2*A173+y3*C006+y4*X001+y5*X003"
plot(my.model)
plot(my.model, col="yellow", sizeMan=10)
plot(my.model, col="yellow", sizeMan=8)
fun.reg <- function(dt) { fit <- try(lm(A170~A009+A173+C006+X001+X003, data=dt), silent=TRUE)
## If there are errors during the analysis, it returns missing values.
if (is.element("try-error", class(fit))) {
c(y1=NA,y2=NA,y3=NA,y4=NA,y5=NA,
v11=NA,v21=NA,v31=NA,v41=NA,v51=NA,
v22=NA,v32=NA,v42=NA,v52=NA,v33=NA,
v43=NA,v53=NA,v44=NA,v54=NA,v55=NA)
} else {
## Extract the regression coefficients excluding the intercept
y <- unname(coef(fit))
## Extract the sampling covariance matrix excluding the intercept
v <- lav_matrix_vech(vcov(fit)[-1,-1])
c(y1=y[2],y2=y[3],y3=y[4],y4=y[5],y5=y[6],
v11=v[1],v21=v[2],v31=v[3],v41=v[4],v51=v[5],
v22=v[6],v32=v[7],v42=v[8],v52=v[9],v33=v[10],
v43=v[11],v53=v[12],v44=v[13],v54=v[14],v55=v[15])
}
}
########## Split data by Wave and Country and analyze with the fun.reg() function
## Set Wave and Country as key variables for fast reference
## S002: Wave (1 to 6)
## S003: Country
REM1.reg <- WVS %>% group_by(S002, S003) %>% do(mod=(fun.reg(.)))
## Convert it into a data frame and append S002 in the dataset
REM1.reg <- data.frame(S002=REM1.reg$S002,
as.data.frame(t(sapply(REM1.reg$mod, function(x) x))))
## Show part of the results
head(REM1.reg)
########## Meta-analyze results with a random-effects model
REM2.reg <- meta(y=cbind(y1,y2,y3,y4,y5),
v=cbind(v11,v21,v31,v41,v51,v22,v32,v42,v52,v33,v43,v53,v44,v54,v55),
data=REM1.reg,
model.name="Regression analysis REM")
## Rerun the analysis to remove error code
# REM2.reg <- rerun(REM2.reg)
summary(REM2.reg)
rm(list=ls())
## Load the data
load("WVS.Rdata")
## Sample sizes of S002 (Wave) and S003 (Country)
## Please refer to http://www.worldvaluessurvey.org/WVSDocumentationWVL.jsp
## for the country names.
table(WVS[, c("S002","S003")])
## Select the relevant variables to minimize memory usage
WVS <- select(WVS, c(A009, A170, A173, C006, X001, X003, S002, S003))
## Reverse coding for A009
## Recode all negative values as NA
## Age (X003) is divided by 10 to improve numerical stability.
WVS <- mutate(WVS,
A009 = 5-ifelse(A009 < 0, yes=NA, no=A009),
A170 =   ifelse(A170 < 0, yes=NA, no=A170),
A173 =   ifelse(A173 < 0, yes=NA, no=A173),
C006 =   ifelse(C006 < 0, yes=NA, no=C006),
X001 =   ifelse(X001 < 0, yes=NA, no=X001),
X003 =   ifelse(X003 < 0, yes=NA, no=X003/10))
fun.reg <- function(dt) { fit <- try(lm(A170~A009+A173+C006+X001+X003, data=dt),
silent=TRUE)
## If there are errors during the analysis, it returns missing values.
if (is.element("try-error", class(fit))) {
c(y1=NA,y2=NA,y3=NA,y4=NA,y5=NA,
v11=NA,v21=NA,v31=NA,v41=NA,v51=NA,
v22=NA,v32=NA,v42=NA,v52=NA,v33=NA,
v43=NA,v53=NA,v44=NA,v54=NA,v55=NA)
} else {
## Extract the regression coefficients excluding the intercept
y <- unname(coef(fit))
## Extract the sampling covariance matrix excluding the intercept
v <- lav_matrix_vech(vcov(fit)[-1,-1])
c(y1=y[2],y2=y[3],y3=y[4],y4=y[5],y5=y[6],
v11=v[1],v21=v[2],v31=v[3],v41=v[4],v51=v[5],
v22=v[6],v32=v[7],v42=v[8],v52=v[9],v33=v[10],
v43=v[11],v53=v[12],v44=v[13],v54=v[14],v55=v[15])
}
}
########## Split data by Wave and Country and analyze with the fun.reg() function
## Set Wave and Country as key variables for fast reference
## S002: Wave (1 to 6)
## S003: Country
REM1.reg <- WVS %>% group_by(S002, S003) %>% do(mod=(fun.reg(.)))
## Convert it into a data frame and append S002 in the dataset
REM1.reg <- data.frame(S002=REM1.reg$S002,
as.data.frame(t(sapply(REM1.reg$mod, function(x) x))))
## Show part of the results
head(REM1.reg)
REM2.reg <- meta(y=cbind(y1,y2,y3,y4,y5),
v=cbind(v11,v21,v31,v41,v51,v22,v32,v42,v52,
v33,v43,v53,v44,v54,v55),
data=REM1.reg,
model.name="Regression analysis REM")
## Rerun the analysis to remove error code
# REM2.reg <- rerun(REM2.reg)
summary(REM2.reg)
plot(REM2.reg)
warnings()
my.model <- "A170 ~ b*A173 + c*A009
A173 ~ a*A009"
plot(my.model, col="yellow", sizeMan=8)
my.model <- "A170 ~ b*A173 + c*A009
A173 ~ a*A009"
plot(my.model, col="yellow", sizeMan=8)
my.df <- WVS[1:200,  c("F114", "F115", "F116", "F117")]
head(WVS)
## Load the data
load("WVS.Rdata")
my.df <- WVS[1:200,  c("F114", "F115", "F116", "F117")]
head(my.df)
load("WVS.Rdata")
## Select the relevant variables to minimize memory usage
WVS <- select(WVS, c(F114, F115, F116, F117, S002, S003))
## Reverse coding for A009
## Recode all negative values as NA
## Recode all negative values as NA
WVS <- mutate(WVS,
F114 = ifelse(F114 < 0, yes=NA, no=F114),
F115 = ifelse(F115 < 0, yes=NA, no=F115),
F116 = ifelse(F116 < 0, yes=NA, no=F116),
F117 = ifelse(F117 < 0, yes=NA, no=F117))
my.df <- WVS[1:200,  c("F114", "F115", "F116", "F117")]
head(my.df)
?cor
my.dt
my.dt <- my.df
fit <- try(suppressWarnings(cor(my.dt, use="complete.obs")), silent=TRUE)
fit
source('~/.active-rstudio-document')
fit <- try(suppressWarnings(cov(my.dt, use="complete.obs")), silent=TRUE)
fit
complete(my.dt)
complete.cases(my.dt)
length(complete.cases(my.dt))
fun.cor <- function(dt) {
## Calculate the covariance matrix based on the complete data
my.dt <- dt[, c("F114", "F115", "F116", "F117")]
Cov <- try(suppressWarnings(cov(my.dt, use="complete.obs")), silent=TRUE)
## Calculate the sample sizes based on the complete cases
n <- length(complete.cases(my.dt))
if (is.element("try-error", class(Cov))) {
list(Cov=NA, n=NA)
} else {
## regression coefficients excluding the intercept
list(Cov=Cov, n=n)
}
}
########## Split data by Wave and Country and extract the correlation matrices
########## and sample size with the fun.cor() function
stage0.cor <- WVS %>% group_by(S002, S003) %>% do(mod=(fun.cor(.)))
stage0.cor
########## Split data by Wave and Country and extract the correlation matrices
########## and sample size with the fun.cor() function
stage0.cov <- WVS %>% group_by(S002, S003) %>% do(mod=(fun.cor(.)))
## Split the data into a list for ease of data analyses
data.splitted <- split(stage0.cor$mod, 1:nrow(stage0.cor))
head(data.splitted)
data.cov <- lapply(data.splitted, function(x) x$Cov)
data.n <- sapply(data.splitted, function(x) x$n)
data.cov
data.splitted[[1]]
data.splitted[[2]]
data.cov <- lapply(data.splitted, function(x) x[[1]]$Cov)
data.n <- sapply(data.splitted, function(x) x[[1]]$n)
data.cov
data.n
fun.cov <- function(dt) {
my.dt <- dt[, c("F114", "F115", "F116", "F117")]
## Calculate the covariance matrix based on the complete data
Cov <- try(suppressWarnings(cov(my.dt, use="complete.obs")), silent=TRUE)
## Calculate the sample sizes based on the complete cases
n <- length(complete.cases(my.dt))
## Return NA when there are errors
if (is.element("try-error", class(Cov))) {
list(Cov=NA, n=NA)
} else {
## regression coefficients excluding the intercept
list(Cov=Cov, n=n)
}
}
########## Split data by Wave and Country and extract the correlation matrices
########## and sample size with the fun.cor() function
stage0.cov <- WVS %>% group_by(S002, S003) %>% do(mod=(fun.cov(.)))
stage0.cov
data.splitted <- split(stage0.cor$mod, 1:nrow(stage0.cor))
head(data.splitted)
head(data.splitted, n=2)
## A list of covariance matrices
data.cov <- lapply(data.splitted, function(x) x[[1]]$Cov)
head(data.cov, n=2)
data.n <- sapply(data.splitted, function(x) x[[1]]$n)
head(data.n)
REM1.cfa <- tssem1(data.cov, data.n, method="REM", RE.type="Diag",
model.name="One factor model REM")
## Remove groups without any data (n)
index.na <- is.na(data.n)
data.n <- data.n[!index.na]
data.cor <- data.cor[!index.na]
data.cov <- data.cov[!index.na]
REM1.cfa <- tssem1(data.cov, data.n, method="REM", RE.type="Diag",
model.name="One factor model REM")
is.pd(data.cov)
?tssem1
REM1.cfa <- tssem1(data.cov, data.n, method="REM", RE.type="Diag",
cor.analysis = FALSE)
## Rerun the analysis to remove error code
## REM1.cfa <- rerun(REM1.cfa)
summary(REM1.cfa)
## Show the pooled covariance matrix
vec2symMat(coef(REM1.cfa, select="fixed"), diag=TRUE)
## Show the variance components of the random effects
Diag(coef(REM1.cfa, select="random"))
## Setup a one-factor CFA model
cfa.model <- "Fraud =~ F114 + F115 + F116 + F117"
plot(cfa.model)
## Convert it into RAM formulation
RAM <- lavaan2RAM(cfa.model, obs.variables = c("F114","F115","F116","F117"))
RAM
REM2.cfa <- tssem2(REM1.cfa, Amatrix=RAM$A, Smatrix=RAM$S, Fmatrix=RAM$F,
model.name="One factor model REM Stage 2 analysis")
summary(REM2.cfa)
plot(REM2.cfa)
?semPaths
plot(REM2.cfa, what="stand")
## Plot the unstandardized solutions
plot(REM2.cfa, color="yellow")
## Plot the standardized solutions
plot(REM2.cfa, color="green", what="stand")
0.57^2+.68
a <- function(x,y) {x^2+y}
a(.57,.68)
a(.69, .52)
a(.71, .5)
a(.6, .64)
